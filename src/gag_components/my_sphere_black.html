<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>Sphere with Grid</title>
    <style>
      body {
        background-color: #000000;
        margin: 0;
        overflow: hidden;
      }
    </style>
</head>
<body>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/controls/OrbitControls.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/three@0.122.0/build/three.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/three@0.122.0/examples/js/controls/OrbitControls.min.js"></script>
      <script>

      //-----------------------------------------------------------------------
      // projections func
      //-----------------------------------------------------------------------
      function GeoVdek(r, phi, lmbd)
      {
            phi = phi * Math.PI / 180;
            lmbd = lmbd * Math.PI / 180;

            var X = r * Math.cos(phi) * Math.cos(lmbd);
            var Y = r * Math.cos(phi) * Math.sin(lmbd);
            var Z = r * Math.sin(phi);

            var C = RotateAroundV([X, Y, Z], [1,0,0], 90);
            return C;
      }

      function DekVgeo(x, y, z)
      {
            var R = 1;
            var phi = Math.asin(z / R) * 180 / Math.PI;
            var lmbd = Math.atan(y / x) * 180 / Math.PI;
            return [phi, lmbd];
      }

      function vector_length(v) { return Math.sqrt( v[0] * v[0] + v[1] * v[1] + v[2] * v[2] ); }





      //-----------------------------------------------------------------------
      // matrix mod functions
      //-----------------------------------------------------------------------

      function MultiplyMatrix(A,B)
      {
          var C = [0, 0, 0];

          C[0] = A[0][0] * B[0] + A[0][1] * B[1] + A[0][2] * B[2];
          C[1] = A[1][0] * B[0] + A[1][1] * B[1] + A[1][2] * B[2];
          C[2] = A[2][0] * B[0] + A[2][1] * B[1] + A[2][2] * B[2];

          return C;
      }

      function RotateAroundV(B, V, phi)
      {
          phi = phi * Math.PI / 180;

          var x = V[0];
          var y = V[1];
          var z = V[2];

          let A = [
            [Math.cos(phi) + (1 - Math.cos(phi)) * x * x, (1 - Math.cos(phi)) * x * y - z * Math.sin(phi), (1 - Math.cos(phi)) * x * z + y * Math.sin(phi)],
            [(1 - Math.cos(phi)) * y * x + z * Math.sin(phi), Math.cos(phi) + (1 - Math.cos(phi)) * y * y, (1 - Math.cos(phi)) * y * z - x * Math.sin(phi)],
            [(1 - Math.cos(phi)) * z * x - y * Math.sin(phi), (1 - Math.cos(phi)) * z * y + x * Math.sin(phi), Math.cos(phi) + (1 - Math.cos(phi)) * z * z]
          ];

          var C = MultiplyMatrix(A, B)

          return C;
      }

      function NormalizeV(V)
      {
          var x = V[0];
          var y = V[1];
          var z = V[2];

         var L = Math.sqrt(x * x + y * y + z * z);

          var C = [x / L, y / L, z / L];

          return C;
      }

      //-----------------------------------------------------------------------
	  // circle plot func
      //-----------------------------------------------------------------------

      function PlotCircle(direction, phi, scene, my_color, dashed)
      {
          if (dashed == 0) {
              direction = NormalizeV(direction);

              if ((direction[0] == -1 || direction[0] == 1) && direction[1] == 0 && direction[2] == 0){
                var xp = 0;
                var yp = 1;
                var zp = 1;
                var perp = NormalizeV([xp, yp, zp]);
                }
              else if (direction[0] == 0 && (direction[1] == -1 || direction[1] == 1) && direction[2] == 0){
                var xp = 1;
                var yp = 0;
                var zp = 1;
                var perp = NormalizeV([xp, yp, zp]);
                }
              else if (direction[0] == 0 && direction[1] == 0 && (direction[2] == 1 || direction[2] == -1)){
                var xp = 1;
                var yp = 1;
                var zp = 0;
                var perp = NormalizeV([xp, yp, zp]);
                }
              else {
                var xp = Math.random() * (0.001 - 0.0001) + 0.0001;
                var yp = Math.random() * (0.001 - 0.0001) + 0.0001;
                var zp = (-1) * (direction[0] * xp + direction[1] * yp) / direction[2];
                var perp = NormalizeV([xp, yp, zp]);
                }

              var my_point = direction;
              my_point = RotateAroundV(my_point, perp, phi);

              var points4 = [];

              points4.push( new THREE.Vector3( my_point[0], my_point[1], my_point[2] ) );

              for ( let i = 0; i < 720; i ++ ) {
                my_point = RotateAroundV(my_point, direction, 0.5);
                points4.push( new THREE.Vector3( my_point[0], my_point[1], my_point[2] ) );
              }

              var geometry4 = new THREE.BufferGeometry().setFromPoints( points4 );
              var material4 = new THREE.LineBasicMaterial({ color: my_color, linewidth: 2});


              //0xFF5454
              var line4 = new THREE.Line( geometry4, material4 );
              scene.add( line4 );
          }
          else {

              direction = NormalizeV(direction);

              if ((direction[0] == -1 || direction[0] == 1) && direction[1] == 0 && direction[2] == 0){
                var xp = 0;
                var yp = 1;
                var zp = 1;
                var perp = NormalizeV([xp, yp, zp]);
                }
              else if (direction[0] == 0 && (direction[1] == -1 || direction[1] == 1) && direction[2] == 0){
                var xp = 1;
                var yp = 0;
                var zp = 1;
                var perp = NormalizeV([xp, yp, zp]);
                }
              else if (direction[0] == 0 && direction[1] == 0 && (direction[2] == 1 || direction[2] == -1)){
                var xp = 1;
                var yp = 1;
                var zp = 0;
                var perp = NormalizeV([xp, yp, zp]);
                }
              else {
                var xp = Math.random() * (0.001 - 0.0001) + 0.0001;
                var yp = Math.random() * (0.001 - 0.0001) + 0.0001;
                var zp = (-1) * (direction[0] * xp + direction[1] * yp) / direction[2];
                var perp = NormalizeV([xp, yp, zp]);
                }

              var my_point = direction;
              my_point = RotateAroundV(my_point, perp, phi);

              var points4 = [];

              points4.push( new THREE.Vector3( my_point[0], my_point[1], my_point[2] ) );

              //-------------------------------------------------------------------
              //-------------------------------------------------------------------

              for ( let j = 0; j < 72; j ++ ) {
                  if ( j % 2 == 0){
                      for ( let i = 0; i < 20; i ++ ) {
                        my_point = RotateAroundV(my_point, direction, 0.5);
                        points4.push( new THREE.Vector3( my_point[0], my_point[1], my_point[2] ) );

                      }

                      var geometry4 = new THREE.BufferGeometry().setFromPoints( points4 );
                      var material4 = new THREE.LineBasicMaterial({ color: my_color, linewidth: 2});

                      //0xFF5454
                      var line4 = new THREE.Line( geometry4, material4 );
                      scene.add( line4 );
                  }
                  else {
                     for ( let i = 0; i < 20; i ++ ) {
                        my_point = RotateAroundV(my_point, direction, 0.5);

                     }
                  }
                  points4 = [];
              }
              //-------------------------------------------------------------------
              //-------------------------------------------------------------------


          }
      }

      //-----------------------------------------------------------------------
	  // begin
      //-----------------------------------------------------------------------
      //-----------------------------------------------------------------------
	  // Set up the scene
      //-----------------------------------------------------------------------

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0000);

      // Set up the camera
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.9,
        1000
      );

      camera.position.z = 2;

      // Set up the renderer
      var renderer = new THREE.WebGLRenderer( { antialias: true } );
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);


      //Create a PointLight and turn on shadows for the light
      const light = new THREE.PointLight( 0xffffff, 1, 100 );
      scene.add( light );


      //-----------------------------------------------------------
      // draw sphere grid
      //-----------------------------------------------------------

      var point = [0, 0, 1];
      PlotCircle(point, 90, scene, 0x00849C, 0);

      var mers = 18;
      var paralels = 18;


      for ( var i = 0; i < mers; i ++ ) {
          point = RotateAroundV(point, [0, 1, 0], 360 / mers);
          PlotCircle(point, 90, scene, 0x00849C, 0);
        }

      for ( var i = 0; i < paralels; i ++ ) {
          PlotCircle([0, 1, 0], i * 10, scene, 0x00849C, 0);
        }

        function DekVgeo(x, y, z)
        {
            var R = 1;
            var phi = Math.asin(z / R) * 180 / Math.PI;
            var lmbd = Math.atan(y / x) * 180 / Math.PI;
            return [phi, lmbd];
        }




      //-----------------------------------------------------------------------
      // test
      //-----------------------------------------------------------------------
      function dotPlot(m, my_color){
        var dotGeometry = new THREE.Geometry();
        var m1 = NormalizeV(m);
        
        dotGeometry.vertices.push(new THREE.Vector3(m1[0], m1[1], m1[2]));
        var dotMaterial = new THREE.PointsMaterial( { color: my_color, size: 10, sizeAttenuation: false } );
        var dot = new THREE.Points( dotGeometry, dotMaterial );
        scene.add( dot );
      }


      function linePlot(m, my_color){
        var points4 = [];
        for ( let i = 0; i < m.length; i ++ ) {
          points4.push( new THREE.Vector3( m[i][0], m[i][1], m[i][2] ) );
        }
        var geometry4 = new THREE.BufferGeometry().setFromPoints( points4 );
        var material4 = new THREE.LineBasicMaterial({ color: my_color, linewidth: 2});
        var line4 = new THREE.Line( geometry4, material4 );
        scene.add( line4 );
      }

      
      function get_perp(v1,v2)
      {
          var x1 = v1[0];
          var y1 = v1[1];
          var z1 = v1[2];

          var x2 = v2[0];
          var y2 = v2[1];
          var z2 = v2[2];

          var i = y1 * z2 - z1 * y2;
          var j = z1 * x2 - x1 * z2;
          var k = x1 * y2 - y1 * x2;

          return NormalizeV([i,j,k]);
      }

      function convertPoint(point, newAxes) {
        const deltaX = point[0];
        const deltaY = point[1];
        const deltaZ = point[2];

        const transformedX = newAxes[0][0] * deltaX + newAxes[1][0] * deltaY + newAxes[2][0] * deltaZ;
        const transformedY = newAxes[0][1] * deltaX + newAxes[1][1] * deltaY + newAxes[2][1] * deltaZ;
        const transformedZ = newAxes[0][2] * deltaX + newAxes[1][2] * deltaY + newAxes[2][2] * deltaZ;

        return [transformedX, transformedY, transformedZ];
      }

      function angle_between(v1, v2)
      {
          var angle;
          angle = Math.acos( (v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]) / ( vector_length(v1) * vector_length(v2) ) );
          if (angle > 180) { angle -= 180; }
              return angle;
      }

      function MultiplyMatrix(A, B)
      {
          var C = [0, 0, 0];

          C[0] = A[0][0] * B[0] + A[0][1] * B[1] + A[0][2] * B[2];
          C[1] = A[1][0] * B[0] + A[1][1] * B[1] + A[1][2] * B[2];
          C[2] = A[2][0] * B[0] + A[2][1] * B[1] + A[2][2] * B[2];

          return C;
      }
      function RotateAroundZ(B, phi)
      {
          phi = phi * Math.PI / 180;

          let A = [
                      [ Math.cos(phi), -Math.sin(phi), 0 ],
                      [ Math.sin(phi), Math.cos(phi), 0 ],
                      [ 0, 0, 1 ],
                  ];

          var C = MultiplyMatrix(A, B)

          return C;
      }

      function RotateAroundY(B, phi)
      {
          phi = phi * Math.PI / 180;

          let A = [
                      [ Math.cos(phi), 0, Math.sin(phi) ],
                      [ 0, 1, 0 ],
                      [ -Math.sin(phi), 0, Math.cos(phi) ],
                  ];

          var C = MultiplyMatrix(A, B)

          return C;
      }
      function RotateAroundX(B, phi)
      {
          phi = phi * Math.PI / 180;

          let A = [
                      [ 1, 0, 0 ],
                      [ 0, Math.cos(phi), -Math.sin(phi) ],
                      [ 0, Math.sin(phi), Math.cos(phi) ],
                  ];

          var C = MultiplyMatrix(A, B)

          return C;
      }




      var green = 0x0f87a;
      var red = 0xFF5454;
      var blue = 0xaaaa;
      var purple = 0xa834eb;
      var pink = 0xeb34eb;


      // dotPlot(, red);


      // linePlot([x_axis, [0,0,0], y_axis, [0,0,0], z_axis, [0,0,0]], red);
      dotPlot([1,0,0], red);
      console.log(DekVgeo(1, 0, 0));

      dotPlot(RotateAroundY([1,0,0], 10), green);

      console.log(DekVgeo(RotateAroundY([1,0,0], 10)[0], RotateAroundY([1,0,0], 10)[1], RotateAroundY([1,0,0], 10)[2]));
      //-----------------------------------------------------------------------
	    // render anim
      //-----------------------------------------------------------------------





      // Set up the controls
      var controls = new THREE.OrbitControls(camera, renderer.domElement);

      // Animate the scene
      var animate = function () {
        requestAnimationFrame(animate);
        light.position.copy( camera.position );
        controls.update();

        renderer.render(scene, camera);
      };

      animate();

</script>

</body>
</html>
