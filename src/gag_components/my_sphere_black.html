<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>Sphere with Grid</title>
    <style>
      body {
        background-color: #000000;
        margin: 0;
        overflow: hidden;
      }
    </style>
</head>
<body>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/controls/OrbitControls.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/three@0.122.0/build/three.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/three@0.122.0/examples/js/controls/OrbitControls.min.js"></script>
      <script>

      //-----------------------------------------------------------------------
      // projections func
      //-----------------------------------------------------------------------
      function GeoVdek(r, phi, lmbd)
      {
            phi = phi * Math.PI / 180;
            lmbd = lmbd * Math.PI / 180;

            var X = r * Math.cos(phi) * Math.cos(lmbd);
            var Y = r * Math.cos(phi) * Math.sin(lmbd);
            var Z = r * Math.sin(phi);

            var C = RotateAroundV([X, Y, Z], [1,0,0], 90);
            return C;
      }

      function DekVgeo(x, y, z)
      {
            var R = 1;
            var phi = Math.asin(z / R) * 180 / Math.PI;
            var lmbd = Math.atan(y / x) * 180 / Math.PI;
            return [phi, lmbd];
      }

      function vector_length(v) { return Math.sqrt( v[0] * v[0] + v[1] * v[1] + v[2] * v[2] ); }





      //-----------------------------------------------------------------------
      // matrix mod functions
      //-----------------------------------------------------------------------

      function MultiplyMatrix(A,B)
      {
          var C = [0, 0, 0];

          C[0] = A[0][0] * B[0] + A[0][1] * B[1] + A[0][2] * B[2];
          C[1] = A[1][0] * B[0] + A[1][1] * B[1] + A[1][2] * B[2];
          C[2] = A[2][0] * B[0] + A[2][1] * B[1] + A[2][2] * B[2];

          return C;
      }

      function RotateAroundV(B, V, phi)
      {
          phi = phi * Math.PI / 180;

          var x = V[0];
          var y = V[1];
          var z = V[2];

          let A = [
            [Math.cos(phi) + (1 - Math.cos(phi)) * x * x, (1 - Math.cos(phi)) * x * y - z * Math.sin(phi), (1 - Math.cos(phi)) * x * z + y * Math.sin(phi)],
            [(1 - Math.cos(phi)) * y * x + z * Math.sin(phi), Math.cos(phi) + (1 - Math.cos(phi)) * y * y, (1 - Math.cos(phi)) * y * z - x * Math.sin(phi)],
            [(1 - Math.cos(phi)) * z * x - y * Math.sin(phi), (1 - Math.cos(phi)) * z * y + x * Math.sin(phi), Math.cos(phi) + (1 - Math.cos(phi)) * z * z]
          ];

          var C = MultiplyMatrix(A, B)

          return C;
      }

      function NormalizeV(V)
      {
          var x = V[0];
          var y = V[1];
          var z = V[2];

         var L = Math.sqrt(x * x + y * y + z * z);

          var C = [x / L, y / L, z / L];

          return C;
      }

      //-----------------------------------------------------------------------
	  // circle plot func
      //-----------------------------------------------------------------------

      function PlotCircle(direction, phi, scene, my_color, dashed)
      {
          if (dashed == 0) {
              direction = NormalizeV(direction);

              if ((direction[0] == -1 || direction[0] == 1) && direction[1] == 0 && direction[2] == 0){
                var xp = 0;
                var yp = 1;
                var zp = 1;
                var perp = NormalizeV([xp, yp, zp]);
                }
              else if (direction[0] == 0 && (direction[1] == -1 || direction[1] == 1) && direction[2] == 0){
                var xp = 1;
                var yp = 0;
                var zp = 1;
                var perp = NormalizeV([xp, yp, zp]);
                }
              else if (direction[0] == 0 && direction[1] == 0 && (direction[2] == 1 || direction[2] == -1)){
                var xp = 1;
                var yp = 1;
                var zp = 0;
                var perp = NormalizeV([xp, yp, zp]);
                }
              else {
                var xp = Math.random() * (0.001 - 0.0001) + 0.0001;
                var yp = Math.random() * (0.001 - 0.0001) + 0.0001;
                var zp = (-1) * (direction[0] * xp + direction[1] * yp) / direction[2];
                var perp = NormalizeV([xp, yp, zp]);
                }

              var my_point = direction;
              my_point = RotateAroundV(my_point, perp, phi);

              var points4 = [];

              points4.push( new THREE.Vector3( my_point[0], my_point[1], my_point[2] ) );

              for ( let i = 0; i < 720; i ++ ) {
                my_point = RotateAroundV(my_point, direction, 0.5);
                points4.push( new THREE.Vector3( my_point[0], my_point[1], my_point[2] ) );
              }

              var geometry4 = new THREE.BufferGeometry().setFromPoints( points4 );
              var material4 = new THREE.LineBasicMaterial({ color: my_color, linewidth: 2});


              //0xFF5454
              var line4 = new THREE.Line( geometry4, material4 );
              scene.add( line4 );
          }
          else {

              direction = NormalizeV(direction);

              if ((direction[0] == -1 || direction[0] == 1) && direction[1] == 0 && direction[2] == 0){
                var xp = 0;
                var yp = 1;
                var zp = 1;
                var perp = NormalizeV([xp, yp, zp]);
                }
              else if (direction[0] == 0 && (direction[1] == -1 || direction[1] == 1) && direction[2] == 0){
                var xp = 1;
                var yp = 0;
                var zp = 1;
                var perp = NormalizeV([xp, yp, zp]);
                }
              else if (direction[0] == 0 && direction[1] == 0 && (direction[2] == 1 || direction[2] == -1)){
                var xp = 1;
                var yp = 1;
                var zp = 0;
                var perp = NormalizeV([xp, yp, zp]);
                }
              else {
                var xp = Math.random() * (0.001 - 0.0001) + 0.0001;
                var yp = Math.random() * (0.001 - 0.0001) + 0.0001;
                var zp = (-1) * (direction[0] * xp + direction[1] * yp) / direction[2];
                var perp = NormalizeV([xp, yp, zp]);
                }

              var my_point = direction;
              my_point = RotateAroundV(my_point, perp, phi);

              var points4 = [];

              points4.push( new THREE.Vector3( my_point[0], my_point[1], my_point[2] ) );

              //-------------------------------------------------------------------
              //-------------------------------------------------------------------

              for ( let j = 0; j < 72; j ++ ) {
                  if ( j % 2 == 0){
                      for ( let i = 0; i < 20; i ++ ) {
                        my_point = RotateAroundV(my_point, direction, 0.5);
                        points4.push( new THREE.Vector3( my_point[0], my_point[1], my_point[2] ) );

                      }

                      var geometry4 = new THREE.BufferGeometry().setFromPoints( points4 );
                      var material4 = new THREE.LineBasicMaterial({ color: my_color, linewidth: 2});

                      //0xFF5454
                      var line4 = new THREE.Line( geometry4, material4 );
                      scene.add( line4 );
                  }
                  else {
                     for ( let i = 0; i < 20; i ++ ) {
                        my_point = RotateAroundV(my_point, direction, 0.5);

                     }
                  }
                  points4 = [];
              }
              //-------------------------------------------------------------------
              //-------------------------------------------------------------------


          }
      }

      //-----------------------------------------------------------------------
	  // begin
      //-----------------------------------------------------------------------
      //-----------------------------------------------------------------------
	  // Set up the scene
      //-----------------------------------------------------------------------

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0000);

      // Set up the camera
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.9,
        1000
      );

      camera.position.z = 2;

      // Set up the renderer
      var renderer = new THREE.WebGLRenderer( { antialias: true } );
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);


      //Create a PointLight and turn on shadows for the light
      const light = new THREE.PointLight( 0xffffff, 1, 100 );
      scene.add( light );


      //-----------------------------------------------------------
      // draw sphere grid
      //-----------------------------------------------------------

      var point = [0, 0, 1];
      PlotCircle(point, 90, scene, 0x00849C, 0);

      for ( var i = 0; i < 19; i ++ ) {
          point = RotateAroundV(point, [0, 1, 0], 10);
          PlotCircle(point, 90, scene, 0x00849C, 0);
        }

      for ( var i = 0; i < 19; i ++ ) {
          PlotCircle([0, 1, 0], i * 10, scene, 0x00849C, 0);
        }


      //-----------------------------------------------------------------------
      // test
      //-----------------------------------------------------------------------
      function dotPlot(m, my_color){
        var dotGeometry = new THREE.Geometry();
        var m1 = NormalizeV(m);
        
        dotGeometry.vertices.push(new THREE.Vector3(m1[0], m1[1], m1[2]));
        var dotMaterial = new THREE.PointsMaterial( { color: my_color, size: 10, sizeAttenuation: false } );
        var dot = new THREE.Points( dotGeometry, dotMaterial );
        scene.add( dot );
      }


      function linePlot(m, my_color){
        var points4 = [];
        for ( let i = 0; i < m.length; i ++ ) {
          points4.push( new THREE.Vector3( m[i][0], m[i][1], m[i][2] ) );
        }
        var geometry4 = new THREE.BufferGeometry().setFromPoints( points4 );
        var material4 = new THREE.LineBasicMaterial({ color: my_color, linewidth: 2});
        var line4 = new THREE.Line( geometry4, material4 );
        scene.add( line4 );
      }

      
      function get_perp(v1,v2)
      {
          var x1 = v1[0];
          var y1 = v1[1];
          var z1 = v1[2];

          var x2 = v2[0];
          var y2 = v2[1];
          var z2 = v2[2];

          var i = y1 * z2 - z1 * y2;
          var j = z1 * x2 - x1 * z2;
          var k = x1 * y2 - y1 * x2;

          return NormalizeV([i,j,k]);
      }

      function convertPoint(point, newAxes) {
        const deltaX = point[0];
        const deltaY = point[1];
        const deltaZ = point[2];

        const transformedX = newAxes[0][0] * deltaX + newAxes[1][0] * deltaY + newAxes[2][0] * deltaZ;
        const transformedY = newAxes[0][1] * deltaX + newAxes[1][1] * deltaY + newAxes[2][1] * deltaZ;
        const transformedZ = newAxes[0][2] * deltaX + newAxes[1][2] * deltaY + newAxes[2][2] * deltaZ;

        return [transformedX, transformedY, transformedZ];
      }

      function angle_between(v1, v2)
      {
          var angle;
          angle = Math.acos( (v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]) / ( vector_length(v1) * vector_length(v2) ) );
          if (angle > 180) { angle -= 180; }
              return angle;
      }

      function MultiplyMatrix(A, B)
      {
          var C = [0, 0, 0];

          C[0] = A[0][0] * B[0] + A[0][1] * B[1] + A[0][2] * B[2];
          C[1] = A[1][0] * B[0] + A[1][1] * B[1] + A[1][2] * B[2];
          C[2] = A[2][0] * B[0] + A[2][1] * B[1] + A[2][2] * B[2];

          return C;
      }
      function RotateAroundZ(B, phi)
      {
          phi = phi * Math.PI / 180;

          let A = [
                      [ Math.cos(phi), -Math.sin(phi), 0 ],
                      [ Math.sin(phi), Math.cos(phi), 0 ],
                      [ 0, 0, 1 ],
                  ];

          var C = MultiplyMatrix(A, B)

          return C;
      }

      function RotateAroundY(B, phi)
      {
          phi = phi * Math.PI / 180;

          let A = [
                      [ Math.cos(phi), 0, Math.sin(phi) ],
                      [ 0, 1, 0 ],
                      [ -Math.sin(phi), 0, Math.cos(phi) ],
                  ];

          var C = MultiplyMatrix(A, B)

          return C;
      }
      function RotateAroundX(B, phi)
      {
          phi = phi * Math.PI / 180;

          let A = [
                      [ 1, 0, 0 ],
                      [ 0, Math.cos(phi), -Math.sin(phi) ],
                      [ 0, Math.sin(phi), Math.cos(phi) ],
                  ];

          var C = MultiplyMatrix(A, B)

          return C;
      }


     // find new basis
     function test(center, sign_numb, my_var) {
      var green = 0x0f87a;
      var red = 0xFF5454;
      var blue = 0xaaaa;
      var purple = 0xa834eb;
      var pink = 0xeb34eb;


      if (sign_numb == 1) {
        var my_sign = [1,1,1];
      }
      if (sign_numb == 2) {
        var my_sign = [1,-1,1];
      }
      if (sign_numb == 3) {
        var my_sign = [1,1,-1];
      }
      if (sign_numb == 4) {
        var my_sign = [1,-1,-1];
      }
      if (sign_numb == 5) {
        var my_sign = [-1,1,1];
      }
      if (sign_numb == 6) {
        var my_sign = [-1,-1,1];
      }
      if (sign_numb == 7) {
        var my_sign = [-1,1,-1];
      }
      if (sign_numb == 8) {
        var my_sign = [-1,-1,-1];
      }

      //  basis
      var x_axis = [1,0,0];
      var y_axis = [0,1,0];
      var z_axis = [0,0,1];
      var basis = [x_axis, y_axis, z_axis];

      var x_axis1 = get_perp(y_axis, center);
      var y_axis1 = get_perp(center, x_axis1);
      var z_axis1 = center;
      var new_basis1 = [x_axis1, y_axis1, z_axis1];

      linePlot([x_axis1, [0,0,0], y_axis1, [0,0,0], z_axis1, [0,0,0]], purple);


      var x_axis2 = RotateAroundX( z_axis, -angle_between(center, y_axis) * 180 / Math.PI );
      var x_axis2 = [my_sign[0] * x_axis2[0], my_sign[0] * x_axis2[1], my_sign[0] * x_axis2[2]];

      var y_axis2 = RotateAroundV( x_axis, x_axis2, angle_between(x_axis1, x_axis) * 180 / Math.PI  );
      var y_axis2 = [my_sign[1] * y_axis2[0], my_sign[1] * y_axis2[1], my_sign[1] * y_axis2[2]];

      var z_axis2 = get_perp(x_axis2, y_axis2);
      var z_axis2 = [my_sign[2] * z_axis2[0], my_sign[2] * z_axis2[1], my_sign[2] * z_axis2[2]];

      var new_basis2 = [z_axis2, x_axis2, y_axis2];

      if (my_var == 1){var new_basis2 = [ z_axis2, x_axis2, y_axis2];}
      if (my_var == 2){var new_basis2 = [ z_axis2, y_axis2, x_axis2];}
      if (my_var == 3){ var new_basis2 = [ y_axis2, x_axis2, z_axis2];}
      if (my_var == 4){var new_basis2 = [ y_axis2, z_axis2, x_axis2];}
      if (my_var == 5){var new_basis2 = [ x_axis2, z_axis2, y_axis2];}
      if (my_var == 6){var new_basis2 = [ x_axis2, y_axis2, z_axis2];}

      linePlot([x_axis2, [0,0,0], y_axis2, [0,0,0], z_axis2, [0,0,0]]);

      dotPlot(convertPoint(center, new_basis2), pink);

      dotPlot(convertPoint(dot1, new_basis2), pink);
      dotPlot(convertPoint(dot2, new_basis2), pink);
      dotPlot(convertPoint(dot3, new_basis2), pink);
      dotPlot(convertPoint(dot4, new_basis2), pink);

    }

      var green = 0x0f87a;
      var red = 0xFF5454;
      var blue = 0xaaaa;
      var purple = 0xa834eb;
      var pink = 0xeb34eb;

      //  basis
      var x_axis = [1,0,0];
      var y_axis = [0,1,0];
      var z_axis = [0,0,1];
      var basis = [x_axis, y_axis, z_axis];


      dotPlot(x_axis, red);
      dotPlot(y_axis, red);
      dotPlot(z_axis, red);


      linePlot([x_axis, [0,0,0], y_axis, [0,0,0], z_axis, [0,0,0]], red);


      var center = NormalizeV([-1,-1,-1]);

      var dot1 = RotateAroundX( center, 5);
      var dot2 = RotateAroundY( center, 5);
      var dot3 = RotateAroundZ( center, 5);
      var dot4 = RotateAroundV( center, [1, 0, 1], 5);

      // +++
      if (center[0] > 0 && center[1] > 0 && center[2] > 0) { test(center, 2, 1) }
      // +-+
      if (center[0] > 0 && center[1] < 0 && center[2] > 0) { test(center, 2, 1) }
      // ++-
      if (center[0] > 0 && center[1] > 0 && center[2] < 0) { test(center, 1, 1) }
      // +--
      if (center[0] > 0 && center[1] < 0 && center[2] < 0) { test(center, 1, 1) }
      // -++  [-1,1,1] 5 
      if (center[0] < 0 && center[1] > 0 && center[2] > 0) { test(center, 3, 3)}
      // --+ 
      if (center[0] < 0 && center[1] < 0 && center[2] > 0) { test(center, 3, 3) }
      // -+-
      if (center[0] < 0 && center[1] > 0 && center[2] < 0) { test(center, 3, 3) }
      // ---
      if (center[0] < 0 && center[1] < 0 && center[2] < 0) { test(center, 3, 3) }
      
      // 000

      // 0--
      // 0+-
      // 0-+
      // 0++

      // 00-
      // 00+

      // 0-0
      // 0+0

      // -00
      // +00
      
      // -0-
      // +0-
      // -0+
      // +0+

      // --0
      // +-0
      // -+0
      // ++0





      dotPlot(center, green);

      dotPlot(dot1, blue);
      dotPlot(dot2, blue);
      dotPlot(dot3, blue);
      dotPlot(dot4, blue);


      //-----------------------------------------------------------------------
	    // render anim
      //-----------------------------------------------------------------------





      // Set up the controls
      var controls = new THREE.OrbitControls(camera, renderer.domElement);

      // Animate the scene
      var animate = function () {
        requestAnimationFrame(animate);
        light.position.copy( camera.position );
        controls.update();

        renderer.render(scene, camera);
      };

      animate();

</script>

</body>
</html>
